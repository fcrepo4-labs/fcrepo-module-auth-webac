<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WebACRolesProvider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fedora Repository WebAC Authorization Module</a> &gt; <a href="index.source.html" class="el_package">org.fcrepo.auth.webac</a> &gt; <span class="el_source">WebACRolesProvider.java</span></div><h1>WebACRolesProvider.java</h1><pre class="source lang-java linenums">/*
 * Licensed to DuraSpace under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information
 * regarding copyright ownership.
 *
 * DuraSpace licenses this file to you under the Apache License,
 * Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.fcrepo.auth.webac;

import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toSet;
import static java.util.stream.IntStream.range;
import static java.util.stream.Stream.concat;
import static java.util.stream.Stream.empty;
import static java.util.stream.Stream.of;
import static org.apache.jena.graph.NodeFactory.createURI;
import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;
import static org.apache.jena.riot.Lang.TTL;
import static org.fcrepo.auth.webac.URIConstants.FOAF_AGENT_VALUE;
import static org.fcrepo.auth.webac.URIConstants.FOAF_GROUP;
import static org.fcrepo.auth.webac.URIConstants.FOAF_MEMBER_VALUE;
import static org.fcrepo.auth.webac.URIConstants.WEBAC_ACCESS_CONTROL_VALUE;
import static org.fcrepo.auth.webac.URIConstants.WEBAC_ACCESSTO_CLASS_VALUE;
import static org.fcrepo.auth.webac.URIConstants.WEBAC_ACCESSTO_VALUE;
import static org.fcrepo.auth.webac.URIConstants.WEBAC_AGENT_CLASS_VALUE;
import static org.fcrepo.auth.webac.URIConstants.WEBAC_AGENT_VALUE;
import static org.fcrepo.auth.webac.URIConstants.WEBAC_AUTHORIZATION;
import static org.fcrepo.auth.webac.URIConstants.WEBAC_MODE_VALUE;
import static org.fcrepo.auth.webac.URIConstants.WEBAC_NAMESPACE_VALUE;
import static org.fcrepo.kernel.api.RequiredRdfContext.PROPERTIES;
import static org.fcrepo.kernel.modeshape.identifiers.NodeResourceConverter.nodeConverter;
import static org.fcrepo.kernel.modeshape.FedoraSessionImpl.getJcrSession;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.isNonRdfSourceDescription;
import static org.fcrepo.kernel.modeshape.utils.FedoraTypesUtils.getJcrNode;
import static org.slf4j.LoggerFactory.getLogger;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;

import javax.inject.Inject;
import javax.jcr.ItemNotFoundException;
import javax.jcr.Node;
import javax.jcr.RepositoryException;
import javax.jcr.Session;
import javax.jcr.version.Version;
import javax.jcr.version.VersionHistory;

import org.fcrepo.auth.roles.common.AccessRolesProvider;
import org.fcrepo.http.commons.session.SessionFactory;
import org.fcrepo.kernel.api.FedoraSession;
import org.fcrepo.kernel.api.exception.MalformedRdfException;
import org.fcrepo.kernel.api.exception.RepositoryRuntimeException;
import org.fcrepo.kernel.api.identifiers.IdentifierConverter;
import org.fcrepo.kernel.api.models.FedoraResource;
import org.fcrepo.kernel.api.models.NonRdfSourceDescription;
import org.fcrepo.kernel.api.services.NodeService;
import org.fcrepo.kernel.modeshape.FedoraSessionImpl;
import org.fcrepo.kernel.modeshape.rdf.impl.DefaultIdentifierTranslator;

import org.modeshape.jcr.value.Path;
import org.slf4j.Logger;

import org.apache.jena.graph.Triple;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.rdf.model.Statement;
import org.apache.jena.shared.JenaException;

/**
 * @author acoburn
 * @since 9/3/15
 */
<span class="fc" id="L98">public class WebACRolesProvider implements AccessRolesProvider {</span>

    public static final String ROOT_AUTHORIZATION_PROPERTY = &quot;fcrepo.auth.webac.authorization&quot;;

    public static final String GROUP_AGENT_BASE_URI_PROPERTY = &quot;fcrepo.auth.webac.groupAgent.baseUri&quot;;

    public static final String USER_AGENT_BASE_URI_PROPERTY = &quot;fcrepo.auth.webac.userAgent.baseUri&quot;;

<span class="fc" id="L106">    private static final Logger LOGGER = getLogger(WebACRolesProvider.class);</span>

    private static final String FEDORA_INTERNAL_PREFIX = &quot;info:fedora&quot;;

    private static final String ROOT_AUTHORIZATION_LOCATION = &quot;/root-authorization.ttl&quot;;

    private static final String JCR_VERSIONABLE_UUID_PROPERTY = &quot;jcr:versionableUuid&quot;;

    @Inject
    private NodeService nodeService;

    @Inject
    private SessionFactory sessionFactory;

    @Override
    public void postRoles(final Node node, final Map&lt;String, Set&lt;String&gt;&gt; data) throws RepositoryException {
<span class="nc" id="L122">        throw new UnsupportedOperationException(&quot;postRoles() is not implemented&quot;);</span>
    }

    @Override
    public void deleteRoles(final Node node) throws RepositoryException {
<span class="nc" id="L127">        throw new UnsupportedOperationException(&quot;deleteRoles() is not implemented&quot;);</span>
    }

    @Override
    public Map&lt;String, Collection&lt;String&gt;&gt; findRolesForPath(final Path absPath, final Session session)
            throws RepositoryException {
<span class="fc" id="L133">        return getAgentRoles(locateResource(absPath, new FedoraSessionImpl(session)));</span>
    }

    private FedoraResource locateResource(final Path path, final FedoraSession session) {
        try {
<span class="pc bpc" id="L138" title="1 of 4 branches missed.">            if (getJcrSession(session).nodeExists(path.toString()) || path.isRoot()) {</span>
<span class="fc" id="L139">                LOGGER.debug(&quot;findRolesForPath: {}&quot;, path.getString());</span>
<span class="fc" id="L140">                final FedoraResource resource = nodeService.find(session, path.toString());</span>

<span class="fc bfc" id="L142" title="All 2 branches covered.">                if (resource.hasType(&quot;nt:version&quot;)) {</span>
<span class="fc" id="L143">                    LOGGER.debug(&quot;{} is a version, getting the baseVersion&quot;, resource);</span>
<span class="fc" id="L144">                    return getBaseVersion(resource);</span>
                }
<span class="fc" id="L146">                return resource;</span>
            }
<span class="nc" id="L148">        } catch (final RepositoryException ex) {</span>
<span class="nc" id="L149">            throw new RepositoryRuntimeException(ex);</span>
<span class="fc" id="L150">        }</span>
<span class="fc" id="L151">        LOGGER.trace(&quot;Path: {} does not exist, checking parent&quot;, path.getString());</span>
<span class="fc" id="L152">        return locateResource(path.getParent(), session);</span>
    }

    /**
     * Get the versionable FedoraResource for this version resource
     *
     * @param resource the Version resource
     * @return the base versionable resource or the version if not found.
     */
    private FedoraResource getBaseVersion(final FedoraResource resource) {
<span class="fc" id="L162">        final FedoraSession internalSession = sessionFactory.getInternalSession();</span>

        try {
<span class="fc" id="L165">            final VersionHistory base = ((Version) getJcrNode(resource)).getContainingHistory();</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">            if (base.hasProperty(JCR_VERSIONABLE_UUID_PROPERTY)) {</span>
<span class="fc" id="L167">                final String versionUuid = base.getProperty(JCR_VERSIONABLE_UUID_PROPERTY).getValue().getString();</span>
<span class="fc" id="L168">                LOGGER.debug(&quot;versionableUuid : {}&quot;, versionUuid);</span>
<span class="fc" id="L169">                return nodeService.find(internalSession,</span>
<span class="fc" id="L170">                        getJcrSession(internalSession).getNodeByIdentifier(versionUuid).getPath());</span>
            }
<span class="nc" id="L172">        } catch (final ItemNotFoundException e) {</span>
<span class="nc" id="L173">            LOGGER.error(&quot;Node with jcr:versionableUuid not found : {}&quot;, e.getMessage());</span>
<span class="nc" id="L174">        } catch (final RepositoryException e) {</span>
<span class="nc" id="L175">            throw new RepositoryRuntimeException(e);</span>
<span class="nc" id="L176">        }</span>
<span class="nc" id="L177">        return resource;</span>
    }

    @Override
    public Map&lt;String, Collection&lt;String&gt;&gt; getRoles(final Node node, final boolean effective) {
        try {
<span class="nc" id="L183">            return getAgentRoles(nodeService.find(new FedoraSessionImpl(node.getSession()), node.getPath()));</span>
<span class="nc" id="L184">        } catch (final RepositoryException ex) {</span>
<span class="nc" id="L185">            throw new RepositoryRuntimeException(ex);</span>
        }
    }

    /**
     *  For a given FedoraResource, get a mapping of acl:agent values to acl:mode values.
     */
    private Map&lt;String, Collection&lt;String&gt;&gt; getAgentRoles(final FedoraResource resource) {
<span class="fc" id="L193">        LOGGER.debug(&quot;Getting agent roles for: {}&quot;, resource.getPath());</span>

        // Get the effective ACL by searching the target node and any ancestors.
<span class="fc" id="L196">        final Optional&lt;ACLHandle&gt; effectiveAcl = getEffectiveAcl(</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">                isNonRdfSourceDescription.test(getJcrNode(resource)) ?</span>
<span class="fc" id="L198">                    ((NonRdfSourceDescription)nodeConverter.convert(getJcrNode(resource))).getDescribedResource() :</span>
                    resource);

        // Construct a list of acceptable acl:accessTo values for the target resource.
<span class="fc" id="L202">        final List&lt;String&gt; resourcePaths = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L203">        resourcePaths.add(FEDORA_INTERNAL_PREFIX + resource.getPath());</span>

        // Construct a list of acceptable acl:accessToClass values for the target resource.
<span class="fc" id="L206">        final List&lt;URI&gt; rdfTypes = resource.getTypes();</span>

        // Add the resource location and types of the ACL-bearing parent,
        // if present and if different than the target resource.
<span class="fc" id="L210">        effectiveAcl</span>
<span class="fc" id="L211">            .map(aclHandle -&gt; aclHandle.resource)</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            .filter(effectiveResource -&gt; !effectiveResource.getPath().equals(resource.getPath()))</span>
<span class="fc" id="L213">            .ifPresent(effectiveResource -&gt; {</span>
<span class="fc" id="L214">                resourcePaths.add(FEDORA_INTERNAL_PREFIX + effectiveResource.getPath());</span>
<span class="fc" id="L215">                rdfTypes.addAll(effectiveResource.getTypes());</span>
<span class="fc" id="L216">            });</span>

        // If we fall through to the system/classpath-based Authorization and it
        // contains any acl:accessTo properties, it is necessary to add each ancestor
        // path up the node hierarchy, starting at the resource location up to the
        // root location. This way, the checkAccessTo predicate (below) can be properly
        // created to match any acl:accessTo values that are part of the getDefaultAuthorization.
        // This is not relevant if an effectiveAcl is present.
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (!effectiveAcl.isPresent()) {</span>
<span class="fc" id="L225">            resourcePaths.addAll(getAllPathAncestors(resource.getPath()));</span>
        }

        // Create a function to check acl:accessTo, scoped to the given resourcePaths
<span class="fc" id="L229">        final Predicate&lt;WebACAuthorization&gt; checkAccessTo = accessTo.apply(resourcePaths);</span>

        // Create a function to check acl:accessToClass, scoped to the given rdf:type values,
        // but transform the URIs to Strings first.
<span class="fc" id="L233">        final Predicate&lt;WebACAuthorization&gt; checkAccessToClass =</span>
<span class="fc" id="L234">            accessToClass.apply(rdfTypes.stream().map(URI::toString).collect(toList()));</span>

        // Read the effective Acl and return a list of acl:Authorization statements
<span class="fc" id="L237">        final List&lt;WebACAuthorization&gt; authorizations = effectiveAcl</span>
<span class="fc" id="L238">                .map(auth -&gt; getAuthorizations(auth.uri.toString()))</span>
<span class="fc" id="L239">                .orElseGet(() -&gt; getDefaultAuthorizations());</span>

        // Filter the acl:Authorization statements so that they correspond only to statements that apply to
        // the target (or acl-bearing ancestor) resource path or rdf:type.
        // Then, assign all acceptable acl:mode values to the relevant acl:agent values: this creates a UNION
        // of acl:modes for each particular acl:agent.
<span class="fc" id="L245">        final Map&lt;String, Collection&lt;String&gt;&gt; effectiveRoles = new HashMap&lt;&gt;();</span>
<span class="fc" id="L246">        authorizations.stream()</span>
<span class="fc" id="L247">            .filter(checkAccessTo.or(checkAccessToClass))</span>
<span class="fc" id="L248">            .forEach(auth -&gt; {</span>
<span class="fc" id="L249">                concat(auth.getAgents().stream(), dereferenceAgentClasses(auth.getAgentClasses()).stream())</span>
<span class="fc" id="L250">                    .forEach(agent -&gt; {</span>
<span class="fc" id="L251">                        effectiveRoles.computeIfAbsent(agent, key -&gt; new HashSet&lt;&gt;())</span>
<span class="fc" id="L252">                            .addAll(auth.getModes().stream().map(URI::toString).collect(toSet()));</span>
<span class="fc" id="L253">                    });</span>
<span class="fc" id="L254">            });</span>

<span class="fc" id="L256">        LOGGER.debug(&quot;Unfiltered ACL: {}&quot;, effectiveRoles);</span>

<span class="fc" id="L258">        return effectiveRoles;</span>
    }

    /**
     * Given a path (e.g. /a/b/c/d) retrieve a list of all ancestor paths.
     * In this case, that would be a list of &quot;/a/b/c&quot;, &quot;/a/b&quot;, &quot;/a&quot; and &quot;/&quot;.
     */
    private static List&lt;String&gt; getAllPathAncestors(final String path) {
<span class="fc" id="L266">        final List&lt;String&gt; segments = asList(path.split(&quot;/&quot;));</span>
<span class="fc" id="L267">        return range(1, segments.size())</span>
<span class="fc" id="L268">                .mapToObj(frameSize -&gt; FEDORA_INTERNAL_PREFIX + &quot;/&quot; + String.join(&quot;/&quot;, segments.subList(1, frameSize)))</span>
<span class="fc" id="L269">                .collect(toList());</span>
    }

    /**
     *  This is a function for generating a Predicate that filters WebACAuthorizations according
     *  to whether the given acl:accessToClass values contain any of the rdf:type values provided
     *  when creating the predicate.
     */
<span class="fc" id="L277">    private static final Function&lt;List&lt;String&gt;, Predicate&lt;WebACAuthorization&gt;&gt; accessToClass = uris -&gt; auth -&gt;</span>
<span class="fc" id="L278">        uris.stream().anyMatch(uri -&gt; auth.getAccessToClassURIs().contains(uri));</span>

    /**
     *  This is a function for generating a Predicate that filters WebACAuthorizations according
     *  to whether the given acl:accessTo values contain any of the target resource values provided
     *  when creating the predicate.
     */
<span class="fc" id="L285">    private static final Function&lt;List&lt;String&gt;, Predicate&lt;WebACAuthorization&gt;&gt; accessTo = uris -&gt; auth -&gt;</span>
<span class="fc" id="L286">        uris.stream().anyMatch(uri -&gt; auth.getAccessToURIs().contains(uri));</span>

    /**
     *  This maps a Collection of acl:agentClass values to a List of agents.
     *  Any out-of-domain URIs are silently ignored.
     */
    private List&lt;String&gt; dereferenceAgentClasses(final Collection&lt;String&gt; agentClasses) {
<span class="fc" id="L293">        final FedoraSession internalSession = sessionFactory.getInternalSession();</span>
<span class="fc" id="L294">        final IdentifierConverter&lt;Resource, FedoraResource&gt; translator =</span>
<span class="fc" id="L295">                new DefaultIdentifierTranslator(getJcrSession(internalSession));</span>

<span class="fc" id="L297">        final List&lt;String&gt; members = agentClasses.stream().flatMap(agentClass -&gt; {</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            if (agentClass.startsWith(FEDORA_INTERNAL_PREFIX)) {</span>
<span class="fc" id="L299">                final FedoraResource resource = nodeService.find(</span>
<span class="fc" id="L300">                    internalSession, agentClass.substring(FEDORA_INTERNAL_PREFIX.length()));</span>
<span class="fc" id="L301">                return getAgentMembers(translator, resource);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            } else if (agentClass.equals(FOAF_AGENT_VALUE)) {</span>
<span class="nc" id="L303">                return of(agentClass);</span>
            } else {
<span class="nc" id="L305">                LOGGER.info(&quot;Ignoring agentClass: {}&quot;, agentClass);</span>
<span class="nc" id="L306">                return empty();</span>
            }
<span class="fc" id="L308">        }).collect(toList());</span>

<span class="pc bpc" id="L310" title="3 of 4 branches missed.">        if (LOGGER.isDebugEnabled() &amp;&amp; !agentClasses.isEmpty()) {</span>
<span class="nc" id="L311">            LOGGER.debug(&quot;Found {} members in {} agentClass resources&quot;, members.size(), agentClasses.size());</span>
        }

<span class="fc" id="L314">        return members;</span>
    }

    /**
     *  Given a FedoraResource, return a list of agents.
     */
    private static Stream&lt;String&gt; getAgentMembers(final IdentifierConverter&lt;Resource, FedoraResource&gt; translator,
            final FedoraResource resource) {
<span class="fc" id="L322">        return resource.getTriples(translator, PROPERTIES).filter(memberTestFromTypes.apply(resource.getTypes()))</span>
<span class="fc" id="L323">            .map(Triple::getObject).flatMap(WebACRolesProvider::nodeToStringStream);</span>
    }

    /**
     * Map a Jena Node to a Stream of Strings. Any non-URI, non-Literals map to an empty Stream,
     * making this suitable to use with flatMap.
     */
    private static final Stream&lt;String&gt; nodeToStringStream(final org.apache.jena.graph.Node object) {
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (object.isURI()) {</span>
<span class="fc" id="L332">            return of(object.getURI());</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">        } else if (object.isLiteral()) {</span>
<span class="fc" id="L334">            return of(object.getLiteralValue().toString());</span>
        } else {
<span class="nc" id="L336">            return empty();</span>
        }
    }

    /**
     *  A simple predicate for filtering out any non-foaf:member properties
     */
<span class="fc" id="L343">    private static final Function&lt;List&lt;URI&gt;, Predicate&lt;Triple&gt;&gt; memberTestFromTypes = types -&gt; triple -&gt;</span>
<span class="pc bpc" id="L344" title="1 of 4 branches missed.">        types.contains(FOAF_GROUP) &amp;&amp; triple.predicateMatches(createURI(FOAF_MEMBER_VALUE));</span>

    /**
     *  A simple predicate for filtering out any non-acl triples.
     */
<span class="fc" id="L349">    private static final Predicate&lt;Triple&gt; hasAclPredicate = triple -&gt;</span>
<span class="fc" id="L350">        triple.getPredicate().getNameSpace().equals(WEBAC_NAMESPACE_VALUE);</span>

    /**
     *  This function reads a Fedora ACL resource and all of its acl:Authorization children.
     *  The RDF from each child resource is put into a WebACAuthorization object, and the
     *  full list is returned.
     *
     *  @param location the location of the ACL resource
     *  @return a list of acl:Authorization objects
     */
    private List&lt;WebACAuthorization&gt; getAuthorizations(final String location) {

<span class="fc" id="L362">        final FedoraSession internalSession = sessionFactory.getInternalSession();</span>
<span class="fc" id="L363">        final List&lt;WebACAuthorization&gt; authorizations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L364">        final IdentifierConverter&lt;Resource, FedoraResource&gt; translator =</span>
<span class="fc" id="L365">                new DefaultIdentifierTranslator(getJcrSession(internalSession));</span>

<span class="fc" id="L367">        LOGGER.debug(&quot;Effective ACL: {}&quot;, location);</span>

        // Find the specified ACL resource

<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (location.startsWith(FEDORA_INTERNAL_PREFIX)) {</span>

<span class="fc" id="L373">            final FedoraResource resource = nodeService.find(internalSession,</span>
<span class="fc" id="L374">                    location.substring(FEDORA_INTERNAL_PREFIX.length()));</span>

            // Read each child resource, filtering on acl:Authorization type, keeping only acl-prefixed triples.
<span class="fc" id="L377">            resource.getChildren().forEach(child -&gt; {</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">                if (child.getTypes().contains(WEBAC_AUTHORIZATION)) {</span>
<span class="fc" id="L379">                    final Map&lt;String, List&lt;String&gt;&gt; aclTriples = new HashMap&lt;&gt;();</span>
<span class="fc" id="L380">                    child.getTriples(translator, PROPERTIES).filter(hasAclPredicate)</span>
<span class="fc" id="L381">                        .forEach(triple -&gt; {</span>
<span class="fc" id="L382">                            final String predicate = triple.getPredicate().getURI();</span>
<span class="fc" id="L383">                            final List&lt;String&gt; values = aclTriples.computeIfAbsent(predicate,</span>
<span class="fc" id="L384">                                key -&gt; new ArrayList&lt;&gt;());</span>
<span class="fc" id="L385">                            nodeToStringStream(triple.getObject()).forEach(values::add);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">                            if (predicate.equals(WEBAC_AGENT_VALUE)) {</span>
<span class="fc" id="L387">                                additionalAgentValues(triple.getObject()).forEach(values::add);</span>
                            }
<span class="fc" id="L389">                        });</span>
                    // Create a WebACAuthorization object from the provided triples.
<span class="fc" id="L391">                    LOGGER.debug(&quot;Adding acl:Authorization from {}&quot;, child.getPath());</span>
<span class="fc" id="L392">                    authorizations.add(createAuthorizationFromMap(aclTriples));</span>
                }
<span class="fc" id="L394">            });</span>
        }
<span class="fc" id="L396">        return authorizations;</span>
    }

    private static WebACAuthorization createAuthorizationFromMap(final Map&lt;String, List&lt;String&gt;&gt; data) {
<span class="fc" id="L400">        return new WebACAuthorization(</span>
<span class="fc" id="L401">                    data.getOrDefault(WEBAC_AGENT_VALUE, emptyList()),</span>
<span class="fc" id="L402">                    data.getOrDefault(WEBAC_AGENT_CLASS_VALUE, emptyList()),</span>
<span class="fc" id="L403">                    data.getOrDefault(WEBAC_MODE_VALUE, emptyList()).stream()</span>
<span class="fc" id="L404">                                .map(URI::create).collect(toList()),</span>
<span class="fc" id="L405">                    data.getOrDefault(WEBAC_ACCESSTO_VALUE, emptyList()),</span>
<span class="fc" id="L406">                    data.getOrDefault(WEBAC_ACCESSTO_CLASS_VALUE, emptyList()));</span>
    }

    /**
     * Recursively find the effective ACL as a URI along with the FedoraResource that points to it.
     * This way, if the effective ACL is pointed to from a parent resource, the child will inherit
     * any permissions that correspond to access to that parent. This ACL resource may or may not exist,
     * and it may be external to the fedora repository.
     */
    static Optional&lt;ACLHandle&gt; getEffectiveAcl(final FedoraResource resource) {
        try {
<span class="fc" id="L417">            final IdentifierConverter&lt;Resource, FedoraResource&gt; translator =</span>
<span class="fc" id="L418">                new DefaultIdentifierTranslator(getJcrNode(resource).getSession());</span>
<span class="fc" id="L419">            final List&lt;String&gt; acls = resource.getTriples(translator, PROPERTIES)</span>
<span class="fc" id="L420">                    .filter(triple -&gt; triple.getPredicate().equals(createURI(WEBAC_ACCESS_CONTROL_VALUE)))</span>
<span class="fc" id="L421">                    .map(triple -&gt; {</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">                        if (triple.getObject().isURI()) {</span>
<span class="fc" id="L423">                            return triple.getObject().getURI();</span>
                        }
<span class="fc" id="L425">                        final String error = String.format(&quot;The value %s of the %s on this resource must be a URI&quot;,</span>
<span class="fc" id="L426">                                triple.getObject(), WEBAC_ACCESS_CONTROL_VALUE);</span>
<span class="fc" id="L427">                        LOGGER.error(error);</span>
<span class="fc" id="L428">                        throw new MalformedRdfException(error);</span>
<span class="fc" id="L429">                    }).collect(toList());</span>

<span class="fc bfc" id="L431" title="All 2 branches covered.">            if (!acls.isEmpty()) {</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">                if (acls.size() &gt; 1) {</span>
<span class="nc" id="L433">                    LOGGER.warn(&quot;Found multiple ACLs defined for this node. Using: {}&quot;, acls.get(0));</span>
                }
<span class="fc" id="L435">                return Optional.of(new ACLHandle(URI.create(acls.get(0)), resource));</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">            } else if (getJcrNode(resource).getDepth() == 0) {</span>
<span class="fc" id="L437">                LOGGER.debug(&quot;No ACLs defined on this node or in parent hierarchy&quot;);</span>
<span class="fc" id="L438">                return Optional.empty();</span>
            } else {
<span class="fc" id="L440">                LOGGER.trace(&quot;Checking parent resource for ACL. No ACL found at {}&quot;, resource.getPath());</span>
<span class="fc" id="L441">                return getEffectiveAcl(resource.getContainer());</span>
            }
<span class="nc" id="L443">        } catch (final RepositoryException ex) {</span>
<span class="nc" id="L444">            LOGGER.debug(&quot;Exception finding effective ACL: {}&quot;, ex.getMessage());</span>
<span class="nc" id="L445">            return Optional.empty();</span>
        }
    }

    private static List&lt;WebACAuthorization&gt; getDefaultAuthorizations() {
<span class="fc" id="L450">        final Map&lt;String, List&lt;String&gt;&gt; aclTriples = new HashMap&lt;&gt;();</span>
<span class="fc" id="L451">        final List&lt;WebACAuthorization&gt; authorizations = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L453">        getDefaultAcl().listStatements().mapWith(Statement::asTriple).forEachRemaining(triple -&gt; {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (hasAclPredicate.test(triple)) {</span>
<span class="fc" id="L455">                final String predicate = triple.getPredicate().getURI();</span>
<span class="fc" id="L456">                final List&lt;String&gt; values = aclTriples.computeIfAbsent(predicate,</span>
<span class="fc" id="L457">                    key -&gt; new ArrayList&lt;&gt;());</span>
<span class="fc" id="L458">                nodeToStringStream(triple.getObject()).forEach(values::add);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">                if (predicate.equals(WEBAC_AGENT_VALUE)) {</span>
<span class="fc" id="L460">                    additionalAgentValues(triple.getObject()).forEach(values::add);</span>
                }
            }
<span class="fc" id="L463">        });</span>

<span class="fc" id="L465">        authorizations.add(createAuthorizationFromMap(aclTriples));</span>
<span class="fc" id="L466">        return authorizations;</span>
    }

    private static Stream&lt;String&gt; additionalAgentValues(final org.apache.jena.graph.Node object) {
<span class="fc" id="L470">        final String groupBaseUri = System.getProperty(GROUP_AGENT_BASE_URI_PROPERTY);</span>
<span class="fc" id="L471">        final String userBaseUri = System.getProperty(USER_AGENT_BASE_URI_PROPERTY);</span>

<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (object.isURI()) {</span>
<span class="fc" id="L474">            final String uri = object.getURI();</span>
<span class="fc bfc" id="L475" title="All 4 branches covered.">            if (userBaseUri != null &amp;&amp; uri.startsWith(userBaseUri)) {</span>
<span class="fc" id="L476">                return of(uri.substring(userBaseUri.length()));</span>
<span class="fc bfc" id="L477" title="All 4 branches covered.">            } else if (groupBaseUri != null &amp;&amp; uri.startsWith(groupBaseUri)) {</span>
<span class="fc" id="L478">                return of(uri.substring(groupBaseUri.length()));</span>
            }
        }
<span class="fc" id="L481">        return empty();</span>
    }

    private static Model getDefaultAcl() {
<span class="fc" id="L485">        final String rootAcl = System.getProperty(ROOT_AUTHORIZATION_PROPERTY);</span>
<span class="fc" id="L486">        final Model model = createDefaultModel();</span>

<span class="pc bpc" id="L488" title="1 of 4 branches missed.">        if (rootAcl != null &amp;&amp; new File(rootAcl).isFile()) {</span>
            try {
<span class="fc" id="L490">                LOGGER.debug(&quot;Getting root authorization from file: {}&quot;, rootAcl);</span>
<span class="fc" id="L491">                return model.read(rootAcl);</span>
<span class="nc" id="L492">            } catch (final JenaException ex) {</span>
<span class="nc" id="L493">                LOGGER.error(&quot;Error parsing root authorization file: {}&quot;, ex.getMessage());</span>
            }
        }
<span class="pc" id="L496">        try (final InputStream is = WebACRolesProvider.class.getResourceAsStream(ROOT_AUTHORIZATION_LOCATION)) {</span>
<span class="fc" id="L497">            LOGGER.debug(&quot;Getting root authorization from classpath: {}&quot;, ROOT_AUTHORIZATION_LOCATION);</span>
<span class="fc" id="L498">            return model.read(is, null, TTL.getName());</span>
<span class="pc bpc" id="L499" title="6 of 8 branches missed.">        } catch (final IOException ex) {</span>
<span class="nc" id="L500">            LOGGER.error(&quot;Error reading root authorization file: {}&quot;, ex.getMessage());</span>
<span class="nc" id="L501">        } catch (final JenaException ex) {</span>
<span class="nc" id="L502">            LOGGER.error(&quot;Error parsing root authorization file: {}&quot;, ex.getMessage());</span>
<span class="nc" id="L503">        }</span>
<span class="nc" id="L504">        return createDefaultModel();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>